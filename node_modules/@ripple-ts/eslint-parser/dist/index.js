import { createRequire } from "module";

//#region src/index.ts
/**
* The Ripple compiler's AST contains some redundant references (e.g. `Element.attributes`
* and `Element.openingElement.attributes`) that are useful for formatters/source-maps.
* ESLint's traverser will visit both paths and can trigger duplicate rule reports.
*
* For ESLint, we prune JSX wrapper nodes to keep a single traversal path.
*/
function normalizeRippleAstForEslint(ast) {
	const seen = /* @__PURE__ */ new Set();
	const visit = (node) => {
		if (!node || typeof node !== "object") return;
		if (seen.has(node)) return;
		seen.add(node);
		if (node.type === "Element") {
			delete node.openingElement;
			delete node.closingElement;
		}
		for (const key of Object.keys(node)) {
			if (key === "parent" || key === "loc" || key === "range") continue;
			const value = node[key];
			if (Array.isArray(value)) for (const child of value) visit(child);
			else if (value && typeof value === "object") visit(value);
		}
	};
	visit(ast);
}
/**
* Recursively walks the AST and ensures all nodes have range and loc properties
* ESLint's scope analyzer requires these properties on ALL nodes
*/
function ensureNodeProperties(node, code) {
	if (!node || typeof node !== "object") return;
	if (node.start !== void 0 && node.end !== void 0 && !node.range) node.range = [node.start, node.end];
	if (!node.loc && node.start !== void 0 && node.end !== void 0) {
		const lines = code.split("\n");
		let currentPos = 0;
		let startLine = 1;
		let startColumn = 0;
		let endLine = 1;
		let endColumn = 0;
		for (let i = 0; i < lines.length; i++) {
			const lineLength = lines[i].length + 1;
			if (currentPos + lineLength > node.start) {
				startLine = i + 1;
				startColumn = node.start - currentPos;
				break;
			}
			currentPos += lineLength;
		}
		currentPos = 0;
		for (let i = 0; i < lines.length; i++) {
			const lineLength = lines[i].length + 1;
			if (currentPos + lineLength > node.end) {
				endLine = i + 1;
				endColumn = node.end - currentPos;
				break;
			}
			currentPos += lineLength;
		}
		node.loc = {
			start: {
				line: startLine,
				column: startColumn
			},
			end: {
				line: endLine,
				column: endColumn
			}
		};
	}
	for (const key in node) {
		if (key === "parent" || key === "loc" || key === "range") continue;
		const value = node[key];
		if (Array.isArray(value)) value.forEach((child) => ensureNodeProperties(child, code));
		else if (value && typeof value === "object" && value.type) ensureNodeProperties(value, code);
	}
}
/**
* ESLint parser for Ripple (.ripple) files
*
* This parser uses Ripple's built-in compiler to parse .ripple files
* and returns an ESTree-compatible AST for ESLint to analyze.
*/
function parseForESLint(code, options) {
	try {
		const ast = requireRippleCompiler().parse(code);
		if (!ast) throw new Error("Parser returned null or undefined AST");
		normalizeRippleAstForEslint(ast);
		ensureNodeProperties(ast, code);
		return {
			ast: {
				type: ast.type || "Program",
				start: ast.start !== void 0 ? ast.start : 0,
				end: ast.end !== void 0 ? ast.end : code.length,
				loc: ast.loc || {
					start: {
						line: 1,
						column: 0
					},
					end: {
						line: code.split("\n").length,
						column: 0
					}
				},
				range: ast.range || [0, code.length],
				body: ast.body || [],
				sourceType: ast.sourceType || "module",
				comments: ast.comments || [],
				tokens: ast.tokens || []
			},
			services: {},
			visitorKeys: void 0
		};
	} catch (error) {
		throw new SyntaxError(`Failed to parse Ripple file: ${error.message || error}`);
	}
}
/**
* Legacy parse function for older ESLint versions
*/
function parse(code, options) {
	return parseForESLint(code, options).ast;
}
/**
* Helper to require the Ripple compiler
* This handles both CommonJS and ESM environments
*/
function requireRippleCompiler() {
	const globalRipple = globalThis.__RIPPLE_COMPILER__;
	if (globalRipple && globalRipple.parse) return globalRipple;
	try {
		const ripple = createRequire(import.meta.url)("ripple/compiler");
		if (!ripple || !ripple.parse) throw new Error("Ripple compiler loaded but parse function not found.");
		globalThis.__RIPPLE_COMPILER__ = ripple;
		return ripple;
	} catch (error) {
		throw new Error(`Failed to load Ripple compiler: ${error.message}. Make sure the "ripple" package is installed as a peer dependency.`);
	}
}
var src_default = {
	parseForESLint,
	parse
};

//#endregion
export { src_default as default, parse, parseForESLint };
//# sourceMappingURL=index.js.map