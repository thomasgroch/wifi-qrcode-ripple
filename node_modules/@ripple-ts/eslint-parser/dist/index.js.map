{"version":3,"file":"index.js","names":[],"sources":["../src/index.ts"],"sourcesContent":["import type { Program } from 'estree';\nimport type { AST, Linter } from 'eslint';\nimport { createRequire } from 'module';\n\ninterface ParseResult {\n\tast: Program;\n\tservices?: Record<string, any>;\n\tscopeManager?: any;\n\tvisitorKeys?: Record<string, string[]>;\n}\n\n/**\n * The Ripple compiler's AST contains some redundant references (e.g. `Element.attributes`\n * and `Element.openingElement.attributes`) that are useful for formatters/source-maps.\n * ESLint's traverser will visit both paths and can trigger duplicate rule reports.\n *\n * For ESLint, we prune JSX wrapper nodes to keep a single traversal path.\n */\nfunction normalizeRippleAstForEslint(ast: any): void {\n\tconst seen = new Set<any>();\n\tconst visit = (node: any) => {\n\t\tif (!node || typeof node !== 'object') return;\n\t\tif (seen.has(node)) return;\n\t\tseen.add(node);\n\n\t\tif (node.type === 'Element') {\n\t\t\t// Avoid duplicate traversal of attributes/children through openingElement/closingElement.\n\t\t\t// The Element node itself carries the data ESLint rules care about.\n\t\t\tdelete node.openingElement;\n\t\t\tdelete node.closingElement;\n\t\t}\n\n\t\tfor (const key of Object.keys(node)) {\n\t\t\tif (key === 'parent' || key === 'loc' || key === 'range') continue;\n\t\t\tconst value = node[key];\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tfor (const child of value) visit(child);\n\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\tvisit(value);\n\t\t\t}\n\t\t}\n\t};\n\n\tvisit(ast);\n}\n\n/**\n * Recursively walks the AST and ensures all nodes have range and loc properties\n * ESLint's scope analyzer requires these properties on ALL nodes\n */\nfunction ensureNodeProperties(node: any, code: string): void {\n\tif (!node || typeof node !== 'object') {\n\t\treturn;\n\t}\n\n\t// Ensure range property exists\n\tif (node.start !== undefined && node.end !== undefined && !node.range) {\n\t\tnode.range = [node.start, node.end];\n\t}\n\n\t// Ensure loc property exists\n\tif (!node.loc && node.start !== undefined && node.end !== undefined) {\n\t\tconst lines = code.split('\\n');\n\t\tlet currentPos = 0;\n\t\tlet startLine = 1;\n\t\tlet startColumn = 0;\n\t\tlet endLine = 1;\n\t\tlet endColumn = 0;\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst lineLength = lines[i].length + 1;\n\t\t\tif (currentPos + lineLength > node.start) {\n\t\t\t\tstartLine = i + 1;\n\t\t\t\tstartColumn = node.start - currentPos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrentPos += lineLength;\n\t\t}\n\n\t\tcurrentPos = 0;\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst lineLength = lines[i].length + 1;\n\t\t\tif (currentPos + lineLength > node.end) {\n\t\t\t\tendLine = i + 1;\n\t\t\t\tendColumn = node.end - currentPos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrentPos += lineLength;\n\t\t}\n\n\t\tnode.loc = {\n\t\t\tstart: { line: startLine, column: startColumn },\n\t\t\tend: { line: endLine, column: endColumn },\n\t\t};\n\t}\n\n\tfor (const key in node) {\n\t\tif (key === 'parent' || key === 'loc' || key === 'range') {\n\t\t\tcontinue; // Skip these to avoid infinite loops\n\t\t}\n\n\t\tconst value = node[key];\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach((child) => ensureNodeProperties(child, code));\n\t\t} else if (value && typeof value === 'object' && value.type) {\n\t\t\tensureNodeProperties(value, code);\n\t\t}\n\t}\n}\n\n/**\n * ESLint parser for Ripple (.ripple) files\n *\n * This parser uses Ripple's built-in compiler to parse .ripple files\n * and returns an ESTree-compatible AST for ESLint to analyze.\n */\nexport function parseForESLint(code: string, options?: Linter.ParserOptions): ParseResult {\n\ttry {\n\t\t// Dynamically import the Ripple compiler\n\t\t// We use dynamic import to avoid bundling the entire compiler\n\t\tconst rippleCompiler = requireRippleCompiler();\n\n\t\t// Parse the Ripple source code using the Ripple compiler\n\t\tconst ast = rippleCompiler.parse(code);\n\t\tif (!ast) throw new Error('Parser returned null or undefined AST');\n\n\t\t// Normalize for ESLint traversal (avoid duplicate node visits)\n\t\tnormalizeRippleAstForEslint(ast);\n\n\t\t// Recursively ensure all nodes have range and loc properties\n\t\tensureNodeProperties(ast, code);\n\n\t\t// Create a properly structured AST object ensuring all required properties exist\n\t\tconst result: any = {\n\t\t\ttype: ast.type || 'Program',\n\t\t\tstart: ast.start !== undefined ? ast.start : 0,\n\t\t\tend: ast.end !== undefined ? ast.end : code.length,\n\t\t\tloc: ast.loc || {\n\t\t\t\tstart: { line: 1, column: 0 },\n\t\t\t\tend: { line: code.split('\\n').length, column: 0 },\n\t\t\t},\n\t\t\trange: ast.range || [0, code.length],\n\t\t\tbody: ast.body || [],\n\t\t\tsourceType: ast.sourceType || 'module',\n\t\t\tcomments: ast.comments || [],\n\t\t\ttokens: ast.tokens || [],\n\t\t};\n\n\t\treturn {\n\t\t\tast: result,\n\t\t\tservices: {},\n\t\t\tvisitorKeys: undefined, // Use ESLint's default visitor keys\n\t\t};\n\t} catch (error: any) {\n\t\t// Transform Ripple parse errors to ESLint-compatible format\n\t\tthrow new SyntaxError(`Failed to parse Ripple file: ${error.message || error}`);\n\t}\n}\n\n/**\n * Legacy parse function for older ESLint versions\n */\nexport function parse(code: string, options?: Linter.ParserOptions): Program {\n\tconst result = parseForESLint(code, options);\n\treturn result.ast;\n}\n\n/**\n * Helper to require the Ripple compiler\n * This handles both CommonJS and ESM environments\n */\nfunction requireRippleCompiler(): any {\n\tconst globalRipple = (globalThis as any).__RIPPLE_COMPILER__;\n\tif (globalRipple && globalRipple.parse) {\n\t\treturn globalRipple;\n\t}\n\n\ttry {\n\t\t// Use createRequire to dynamically require the module\n\t\t// This works in both ESM and CommonJS contexts\n\t\tconst require = createRequire(import.meta.url);\n\t\tconst ripple = require('ripple/compiler');\n\n\t\tif (!ripple || !ripple.parse) {\n\t\t\tthrow new Error('Ripple compiler loaded but parse function not found.');\n\t\t}\n\n\t\t(globalThis as any).__RIPPLE_COMPILER__ = ripple;\n\n\t\treturn ripple;\n\t} catch (error: any) {\n\t\tthrow new Error(\n\t\t\t`Failed to load Ripple compiler: ${error.message}. ` +\n\t\t\t\t'Make sure the \"ripple\" package is installed as a peer dependency.',\n\t\t);\n\t}\n}\n\ndeclare global {\n\tvar __RIPPLE_COMPILER__: {\n\t\tparse: (source: string) => Program;\n\t\tcompile: (source: string, filename: string, options?: any) => any;\n\t};\n}\n\nexport default {\n\tparseForESLint,\n\tparse,\n};\n"],"mappings":"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"}