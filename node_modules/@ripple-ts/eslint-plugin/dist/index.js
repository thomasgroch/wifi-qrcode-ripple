import { createRequire } from "module";

//#region src/rules/no-module-scope-track.ts
const rule$6 = {
	meta: {
		type: "problem",
		docs: {
			description: "Disallow calling track() at module scope",
			category: "Possible Errors",
			recommended: true
		},
		messages: { moduleScope: "track() cannot be called at module scope. It must be called within a component context." },
		schema: []
	},
	create(context) {
		let componentDepth = 0;
		let functionDepth = 0;
		const incrementComponentDepth = () => componentDepth++;
		const decrementComponentDepth = () => componentDepth--;
		const incrementFunctionDepth = () => functionDepth++;
		const decrementFunctionDepth = () => functionDepth--;
		return {
			Component: incrementComponentDepth,
			"Component:exit": decrementComponentDepth,
			FunctionDeclaration: incrementFunctionDepth,
			"FunctionDeclaration:exit": decrementFunctionDepth,
			FunctionExpression: incrementFunctionDepth,
			"FunctionExpression:exit": decrementFunctionDepth,
			ArrowFunctionExpression: incrementFunctionDepth,
			"ArrowFunctionExpression:exit": decrementFunctionDepth,
			CallExpression(node) {
				if (node.callee.type === "Identifier" && node.callee.name === "track" && componentDepth === 0 && functionDepth === 0) context.report({
					node,
					messageId: "moduleScope"
				});
			}
		};
	}
};

//#endregion
//#region src/rules/prefer-oninput.ts
const rule$5 = {
	meta: {
		type: "suggestion",
		docs: {
			description: "Prefer onInput over onChange for form inputs in Ripple",
			category: "Best Practices",
			recommended: true
		},
		messages: { preferOnInput: "Use \"onInput\" instead of \"onChange\". Ripple does not have synthetic events like React." },
		fixable: "code",
		schema: []
	},
	create(context) {
		return {
			"JSXAttribute[name.name=\"onChange\"]"(node) {
				context.report({
					node,
					messageId: "preferOnInput",
					fix(fixer) {
						return fixer.replaceText(node.name, "onInput");
					}
				});
			},
			"Attribute[name.name=\"onChange\"]"(node) {
				context.report({
					node,
					messageId: "preferOnInput",
					fix(fixer) {
						return fixer.replaceText(node.name, "onInput");
					}
				});
			},
			"Property[key.name=\"onChange\"]"(node) {
				if (context.sourceCode.getAncestors(node).some((ancestor) => ancestor.type === "ObjectExpression")) context.report({
					node,
					messageId: "preferOnInput",
					fix(fixer) {
						return fixer.replaceText(node.key, "onInput");
					}
				});
			}
		};
	}
};

//#endregion
//#region src/rules/no-return-in-component.ts
const rule$4 = {
	meta: {
		type: "problem",
		docs: {
			description: "Disallow return statements with JSX in Ripple components",
			category: "Possible Errors",
			recommended: true
		},
		messages: { noReturn: "Do not return JSX from Ripple components. Use JSX as statements instead." },
		schema: []
	},
	create(context) {
		let insideComponent = 0;
		return {
			"ExpressionStatement > CallExpression[callee.name='component']"() {
				insideComponent++;
			},
			"ExpressionStatement > CallExpression[callee.name='component']:exit"() {
				insideComponent--;
			},
			"VariableDeclarator[init.callee.name=\"component\"]"() {
				insideComponent++;
			},
			"VariableDeclarator[init.callee.name=\"component\"]:exit"() {
				insideComponent--;
			},
			ReturnStatement(node) {
				if (insideComponent > 0 && node.argument) {
					if (node.argument.type === "JSXElement" || node.argument.type === "JSXFragment") context.report({
						node,
						messageId: "noReturn"
					});
				}
			}
		};
	}
};

//#endregion
//#region src/rules/unbox-tracked-values.ts
const rule$3 = {
	meta: {
		type: "problem",
		docs: {
			description: "Ensure tracked values are unboxed with @ operator",
			category: "Possible Errors",
			recommended: true
		},
		messages: { needsUnbox: "Tracked value should be unboxed with @ operator. Did you mean \"@{{name}}\"?" },
		schema: []
	},
	create(context) {
		const trackedVariables = /* @__PURE__ */ new Set();
		function isInJSXContext(node) {
			let parent = node.parent;
			while (parent) {
				const parentType = parent.type;
				if (parentType === "JSXExpressionContainer" || parentType === "JSXElement" || parentType === "JSXFragment" || parentType === "ExpressionContainer" || parentType === "Element") return true;
				parent = parent.parent;
			}
			return false;
		}
		function checkTrackedIdentifier(node) {
			if (trackedVariables.has(node.name) && isInJSXContext(node)) {
				const parent = node.parent;
				let isUnboxed = parent && parent.type === "TrackedExpression" || node.tracked === true;
				if (!isUnboxed) isUnboxed = context.getSourceCode().text.substring(Math.max(0, node.range[0]), node.range[0]) === "@";
				if (!isUnboxed) context.report({
					node,
					messageId: "needsUnbox",
					data: { name: node.name }
				});
			}
		}
		return {
			"VariableDeclarator[init.callee.name=\"track\"]"(node) {
				if (node.id.type === "Identifier") trackedVariables.add(node.id.name);
			},
			Identifier(node) {
				checkTrackedIdentifier(node);
			}
		};
	}
};

//#endregion
//#region src/rules/control-flow-jsx.ts
const rule$2 = {
	meta: {
		type: "problem",
		docs: {
			description: "Require JSX in for...of loops within components, but disallow JSX in for...of loops within effects",
			category: "Possible Errors",
			recommended: true
		},
		messages: {
			requireJsxInLoop: "For...of loops in component bodies should contain JSX elements. Use JSX to render items.",
			noJsxInEffectLoop: "For...of loops inside effect() should not contain JSX. Effects are for side effects, not rendering."
		},
		schema: []
	},
	create(context) {
		let insideComponent = 0;
		let insideEffect = 0;
		function containsJSX(node, visited = /* @__PURE__ */ new Set()) {
			if (!node) return false;
			if (visited.has(node)) return false;
			visited.add(node);
			if (node.type === "JSXElement" || node.type === "JSXFragment" || node.type === "Element") return true;
			const keys = Object.keys(node);
			for (const key of keys) {
				if (key === "parent" || key === "loc" || key === "range") continue;
				const value = node[key];
				if (value && typeof value === "object") {
					if (Array.isArray(value)) {
						for (const item of value) if (item && typeof item === "object" && containsJSX(item, visited)) return true;
					} else if (value.type && containsJSX(value, visited)) return true;
				}
			}
			return false;
		}
		return {
			Component() {
				insideComponent++;
			},
			"Component:exit"() {
				insideComponent--;
			},
			"CallExpression[callee.name='effect']"() {
				insideEffect++;
			},
			"CallExpression[callee.name='effect']:exit"() {
				insideEffect--;
			},
			ForOfStatement(node) {
				if (insideComponent === 0) return;
				const hasJSX = containsJSX(node.body);
				if (insideEffect > 0) {
					if (hasJSX) context.report({
						node,
						messageId: "noJsxInEffectLoop"
					});
				} else if (!hasJSX) context.report({
					node,
					messageId: "requireJsxInLoop"
				});
			}
		};
	}
};

//#endregion
//#region src/rules/no-introspect-in-modules.ts
const rule$1 = {
	meta: {
		type: "problem",
		docs: {
			description: "Disallow @ introspection operator in TypeScript/JavaScript modules",
			category: "Possible Errors",
			recommended: true
		},
		messages: { noIntrospect: "The @ operator cannot be used in TypeScript/JavaScript modules. Use get() to read tracked values and set() to update them instead." },
		schema: []
	},
	create(context) {
		const filename = context.filename || context.getFilename();
		if (filename && filename.endsWith(".ripple")) return {};
		return { Identifier(node) {
			if (node.tracked === true) context.report({
				node,
				messageId: "noIntrospect"
			});
		} };
	}
};

//#endregion
//#region src/rules/valid-for-of-key.ts
const rule = {
	meta: {
		type: "problem",
		docs: {
			description: "Ensure variables used in for..of key expression are defined",
			recommended: true
		},
		messages: { undefinedVariable: "Variable '{{name}}' is not defined." },
		schema: []
	},
	create(context) {
		return { ForOfStatement(node) {
			if (!node.key) return;
			const checkIdentifier = (identifier) => {
				if (!findVariable(context.sourceCode.getScope(node), identifier.name)) context.report({
					node: identifier,
					messageId: "undefinedVariable",
					data: { name: identifier.name }
				});
			};
			const traverse = (node) => {
				if (!node) return;
				switch (node.type) {
					case "Identifier":
						checkIdentifier(node);
						break;
					case "MemberExpression":
						traverse(node.object);
						if (node.computed) traverse(node.property);
						break;
					case "BinaryExpression":
					case "LogicalExpression":
						traverse(node.left);
						traverse(node.right);
						break;
					case "UnaryExpression":
						traverse(node.argument);
						break;
					case "CallExpression":
						traverse(node.callee);
						node.arguments.forEach(traverse);
						break;
					case "ArrayExpression":
						node.elements.forEach(traverse);
						break;
					case "ObjectExpression":
						node.properties.forEach((prop) => {
							if (prop.type === "Property") {
								if (prop.computed) traverse(prop.key);
								traverse(prop.value);
							} else if (prop.type === "SpreadElement") traverse(prop.argument);
						});
						break;
					case "ConditionalExpression":
						traverse(node.test);
						traverse(node.consequent);
						traverse(node.alternate);
						break;
					case "TemplateLiteral":
						node.expressions.forEach(traverse);
						break;
				}
			};
			traverse(node.key);
		} };
	}
};
function findVariable(scope, name) {
	let currentScope = scope;
	while (currentScope) {
		const variable = currentScope.variables.find((v) => v.name === name);
		if (variable) return variable;
		currentScope = currentScope.upper;
	}
	return null;
}

//#endregion
//#region src/index.ts
const plugin = {
	meta: {
		name: "@ripple-ts/eslint-plugin",
		version: "0.1.3"
	},
	rules: {
		"no-module-scope-track": rule$6,
		"prefer-oninput": rule$5,
		"no-return-in-component": rule$4,
		"unbox-tracked-values": rule$3,
		"control-flow-jsx": rule$2,
		"no-introspect-in-modules": rule$1,
		"valid-for-of-key": rule
	},
	configs: {}
};
const require = createRequire(import.meta.url);
let rippleParser;
let tsParser;
try {
	rippleParser = require("@ripple-ts/eslint-parser");
} catch {
	rippleParser = null;
}
try {
	tsParser = require("@typescript-eslint/parser");
} catch {
	tsParser = null;
}
function createConfig(name, files, parser) {
	const config = {
		name,
		files,
		plugins: { ripple: plugin },
		rules: {
			"ripple/no-module-scope-track": "error",
			"ripple/prefer-oninput": "warn",
			"ripple/no-return-in-component": "error",
			"ripple/unbox-tracked-values": "error",
			"ripple/control-flow-jsx": "error",
			"ripple/no-introspect-in-modules": "error",
			"ripple/valid-for-of-key": "error"
		}
	};
	if (parser) config.languageOptions = {
		parser,
		parserOptions: {
			ecmaVersion: "latest",
			sourceType: "module"
		}
	};
	return config;
}
plugin.configs.recommended = [
	createConfig("ripple/recommended-ripple-files", ["**/*.ripple"], rippleParser),
	createConfig("ripple/recommended-typescript-files", ["**/*.ts", "**/*.tsx"], tsParser),
	{
		name: "ripple/ignores",
		ignores: [
			"**/*.d.ts",
			"**/node_modules/**",
			"**/dist/**",
			"**/build/**"
		]
	}
];
plugin.configs.strict = [
	createConfig("ripple/strict-ripple-files", ["**/*.ripple"], rippleParser),
	createConfig("ripple/strict-typescript-files", ["**/*.ts", "**/*.tsx"], tsParser),
	{
		name: "ripple/ignores",
		ignores: [
			"**/*.d.ts",
			"**/node_modules/**",
			"**/dist/**",
			"**/build/**"
		]
	}
];

//#endregion
export { plugin as default };
//# sourceMappingURL=index.js.map